import { WalletConnectModal } from '@walletconnect/modal';
import SignClient from '@walletconnect/sign-client';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _options, _modal, _initSignClientPromise, _signClient, _initModal, initModal_fn, _initSignClient, initSignClient_fn, _createSignClient, createSignClient_fn;
class WalletConnectModalSign {
  constructor(options) {
    // -- private -----------------------------------------------------------
    __privateAdd(this, _initModal);
    __privateAdd(this, _initSignClient);
    __privateAdd(this, _createSignClient);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _modal, void 0);
    __privateAdd(this, _initSignClientPromise, void 0);
    __privateAdd(this, _signClient, void 0);
    __privateSet(this, _options, options);
    __privateSet(this, _modal, __privateMethod(this, _initModal, initModal_fn).call(this));
    __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
  }
  // -- public ------------------------------------------------------------
  async connect(args) {
    const { requiredNamespaces, optionalNamespaces } = args;
    return new Promise(async (resolve, reject) => {
      await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
      const unsubscribeModal = __privateGet(this, _modal).subscribeModal((state) => {
        if (!state.open) {
          unsubscribeModal();
          reject(new Error("Modal closed"));
        }
      });
      const { uri, approval } = await __privateGet(this, _signClient).connect(args);
      if (uri) {
        const namespaceChains = /* @__PURE__ */ new Set();
        if (requiredNamespaces) {
          Object.values(requiredNamespaces).forEach(({ chains }) => {
            if (chains) {
              chains.forEach((chain) => namespaceChains.add(chain));
            }
          });
        }
        if (optionalNamespaces) {
          Object.values(optionalNamespaces).forEach(({ chains }) => {
            if (chains) {
              chains.forEach((chain) => namespaceChains.add(chain));
            }
          });
        }
        await __privateGet(this, _modal).openModal({ uri, chains: Array.from(namespaceChains) });
      }
      try {
        const session = await approval();
        resolve(session);
      } catch (err) {
        reject(err);
      } finally {
        unsubscribeModal();
        __privateGet(this, _modal).closeModal();
      }
    });
  }
  async disconnect(args) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    await __privateGet(this, _signClient).disconnect(args);
  }
  async request(args) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    const result = await __privateGet(this, _signClient).request(args);
    return result;
  }
  async getSessions() {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    return __privateGet(this, _signClient).session.getAll();
  }
  async getSession() {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    return __privateGet(this, _signClient).session.getAll().at(-1);
  }
  async onSessionEvent(callback) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    __privateGet(this, _signClient).on("session_event", callback);
  }
  async offSessionEvent(callback) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    __privateGet(this, _signClient).off("session_event", callback);
  }
  async onSessionUpdate(callback) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    __privateGet(this, _signClient).on("session_update", callback);
  }
  async offSessionUpdate(callback) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    __privateGet(this, _signClient).off("session_update", callback);
  }
  async onSessionDelete(callback) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    __privateGet(this, _signClient).on("session_delete", callback);
  }
  async offSessionDelete(callback) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    __privateGet(this, _signClient).off("session_delete", callback);
  }
  async onSessionExpire(callback) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    __privateGet(this, _signClient).on("session_expire", callback);
  }
  async offSessionExpire(callback) {
    await __privateMethod(this, _initSignClient, initSignClient_fn).call(this);
    __privateGet(this, _signClient).off("session_expire", callback);
  }
}
_options = new WeakMap();
_modal = new WeakMap();
_initSignClientPromise = new WeakMap();
_signClient = new WeakMap();
_initModal = new WeakSet();
initModal_fn = function() {
  const { modalOptions, projectId } = __privateGet(this, _options);
  return new WalletConnectModal(__spreadProps(__spreadValues({}, modalOptions), {
    projectId
  }));
};
_initSignClient = new WeakSet();
initSignClient_fn = async function() {
  if (__privateGet(this, _signClient)) {
    return true;
  }
  if (!__privateGet(this, _initSignClientPromise) && typeof window !== "undefined") {
    __privateSet(this, _initSignClientPromise, __privateMethod(this, _createSignClient, createSignClient_fn).call(this));
  }
  return __privateGet(this, _initSignClientPromise);
};
_createSignClient = new WeakSet();
createSignClient_fn = async function() {
  __privateSet(this, _signClient, await SignClient.init({
    metadata: __privateGet(this, _options).metadata,
    projectId: __privateGet(this, _options).projectId,
    relayUrl: __privateGet(this, _options).relayUrl
  }));
  const clientId = await __privateGet(this, _signClient).core.crypto.getClientId();
  try {
    localStorage.setItem("WCM_WALLETCONNECT_CLIENT_ID", clientId);
  } catch (e) {
    console.info("Unable to set client id");
  }
};

export { WalletConnectModalSign };
//# sourceMappingURL=index.js.map
